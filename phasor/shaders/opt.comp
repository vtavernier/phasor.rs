#version 460 core
#extension GL_ARB_shader_image_load_store : enable

#define K int(gl_WorkGroupSize.x)
#include "shared.h"

layout(local_size_x = CURRENT_K) in;

layout(location = 3, binding = 0, r32f) coherent uniform imageBuffer u_Kernels;

layout(location = 0) uniform ivec3 u_Grid;

#include "gabor.glsl"

shared float[CURRENT_K * NFLOATS * 9] kernels;

void main() {
    int gi = int(gl_WorkGroupID.x) % u_Grid.x;
    int gj = int(gl_WorkGroupID.x) / u_Grid.x;
    vec2 gs = 32.0 / vec2(u_Grid.xy);
    int kernelId = int(gl_GlobalInvocationID.x - gl_WorkGroupID.x * K);

    for (uint opt_steps = 0; opt_steps < 1u; ++opt_steps) {
        // Prefetch kernels into shared memory
        for (int j = -1; j <= 1; j++) {
            for (int i = -1; i <= 1; i++) {
                int ci = cell_idx(i + gi);
                int cj = cell_idy(j + gj);
                if (ci > -1 && cj > -1) {
                    uint idx = ((ci + cj * u_Grid.x) * K + kernelId) * NFLOATS;
                    uint kid = ((i + 1) + (j + 1) * 3) * K * NFLOATS + kernelId * NFLOATS;
                    kernels[kid] = float(ci) + imageLoad(u_Kernels, int(idx) + 0).x;
                    kernels[kid + 1] = float(cj) + imageLoad(u_Kernels, int(idx) + 1).x;
                    kernels[kid + 2] = imageLoad(u_Kernels, int(idx) + 2).x;
                    kernels[kid + 3] = imageLoad(u_Kernels, int(idx) + 3).x;
                    kernels[kid + 4] = imageLoad(u_Kernels, int(idx) + 4).x;
                    kernels[kid + 5] = imageLoad(u_Kernels, int(idx) + 5).x;
                } else {
                    uint kid = ((i + 1) + (j + 1) * 3) * K * NFLOATS + kernelId * NFLOATS;
                    kernels[kid] = -10.0; // impossible value
                    kernels[kid + 1] = -10.0;
                    kernels[kid + 2] = 0.0;
                    kernels[kid + 3] = 0.0;
                    kernels[kid + 4] = 0.0;
                    kernels[kid + 5] = 0.0;
                }
            }
        }
        memoryBarrierShared();

        vec2 kpos;
        float kphase, kangle, kfrequ;
        uint kid = 4 * K * NFLOATS + kernelId * NFLOATS;
        kpos.x = kernels[kid];
        kpos.y = kernels[kid + 1];
        kfrequ = gs.x * kernels[kid + 2];
        kphase = kernels[kid + 3];
        kangle = kernels[kid + 4];
        // for each neighbor, include self
        vec2 npos;
        float nphase, nangle, nfrequ;

        vec2 tv = vec2(0.0);

        for (uint k2 = 0; k2 < K * NFLOATS * 9; k2 += NFLOATS) {
            npos.x = kernels[k2];
            npos.y = kernels[k2 + 1];
            nfrequ = gs.x * kernels[k2 + 2];
            nphase = kernels[k2 + 3];
            nangle = kernels[k2 + 4];
            if (npos.x > -10.0) { // border clamping
                vec2 ph = phasor(kpos - npos, nphase, vec2(cos(nangle), sin(nangle)), nfrequ);
                if (length(ph) > 1e-6) {
                    float w =
                        max(0.0, dot(vec2(cos(nangle), sin(nangle)), vec2(cos(kangle), sin(kangle))));
                    tv += w * normalize(ph);
                }
            }
        }

        float nph = atan(tv.y, tv.x);
        imageStore(u_Kernels, int(gl_GlobalInvocationID.x * NFLOATS) + 3, vec4(nph));
        memoryBarrierImage();
    }
}
