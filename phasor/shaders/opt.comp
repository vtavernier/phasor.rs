#version 460 core
#extension GL_ARB_shader_image_load_store : enable

#define K int(u_KernelCount)
#include "shared.h"

// TODO: All local invocations in [u_KernelCount, MAX_K[ are
// not getting any work done, there might be a more efficient way
layout(local_size_x = MAX_K) in;

layout(location = 4) uniform int u_OptMethod;
layout(location = 5) uniform uint u_OptSteps;

#include "gabor.glsl"

shared float[MAX_K * NFLOATS * 9] kernels;

void main() {
    int gi = int(gl_WorkGroupID.x) % u_Grid.x;
    int gj = int(gl_WorkGroupID.x) / u_Grid.x;
    vec2 gs = 32.0 / vec2(u_Grid.xy);
    int kernelId = int(gl_LocalInvocationID.x);

    for (uint opt_steps = 0; opt_steps < max(1u, u_OptSteps); ++opt_steps) {
        // Prefetch kernels into shared memory
        for (int j = -1; j <= 1; j++) {
            for (int i = -1; i <= 1; i++) {
                int ci = cell_idx(i + gi);
                int cj = cell_idy(j + gj);
                uint kid = (((i + 1) + (j + 1) * 3) * K + kernelId) * NFLOATS;

                if (ci > -1 && cj > -1 && kernelId < K) {
                    int idx = int(((ci + cj * u_Grid.x) * K + kernelId) * NFLOATS);

                    kernels[kid]     = float(ci) + imageLoad(u_Kernels, idx + 0).x;
                    kernels[kid + 1] = float(cj) + imageLoad(u_Kernels, idx + 1).x;
                    kernels[kid + 2] = imageLoad(u_Kernels, idx + 2).x;
                    kernels[kid + 3] = imageLoad(u_Kernels, idx + 3).x;
                    kernels[kid + 4] = imageLoad(u_Kernels, idx + 4).x;
                    kernels[kid + 5] = imageLoad(u_Kernels, idx + 5).x;
                } else {
                    kernels[kid]     = -10.0; // impossible value
                    kernels[kid + 1] = -10.0;
                    kernels[kid + 2] = 0.0;
                    kernels[kid + 3] = 0.0;
                    kernels[kid + 4] = 0.0;
                    kernels[kid + 5] = 0.0;
                }
            }
        }
        memoryBarrierShared();

        if (kernelId < K) {
            vec2 kpos;
            float kphase, kangle, kfrequ;
            uint kid = 4 * K * NFLOATS + kernelId * NFLOATS;
            kpos.x = kernels[kid];
            kpos.y = kernels[kid + 1];
            kfrequ = gs.x * kernels[kid + 2];
            kphase = kernels[kid + 3];
            kangle = kernels[kid + 4];
            // for each neighbor, include self
            vec2 npos;
            float nphase, nangle, nfrequ;

            if (u_OptMethod == OM_OPTIMIZE) {
                float phase_inc = gs.x * kfrequ * 2.0f * M_PI / 64.0;
                const int num_cand_phases = 3;
                float cand_phases[num_cand_phases] = {kphase, kphase - phase_inc,
                                                      kphase + phase_inc};

                // Record votes
                float votes[num_cand_phases];
                for (int i = 0; i < num_cand_phases; i++) {
                    votes[i] = 0;
                }

                for (uint k2 = 0; k2 < K * NFLOATS * 9; k2 += NFLOATS) {
                    npos.x = kernels[k2];
                    npos.y = kernels[k2 + 1];
                    nfrequ = gs.x * kernels[k2 + 2];
                    nphase = kernels[k2 + 3];
                    nangle = kernels[k2 + 4];
                    if (npos.x > -10.0) // border clamping
                    {
                        // evaluate at mid-point
                        vec2 pos = (kpos + npos) / 2.0;
                        // try each phase update, select best
                        float I_max = -1.0;
                        int I_max_arg = -1;
                        vec2 nv =
                            phasor(pos - npos, nphase, vec2(cos(nangle), sin(nangle)), nfrequ);
                        for (int cph = 0; cph < num_cand_phases; cph++) {
                            vec2 kv = phasor(pos - kpos, cand_phases[cph],
                                             vec2(cos(kangle), sin(kangle)), kfrequ);
                            float I = length(nv + kv);
                            if (I > I_max) {
                                I_max = I;
                                I_max_arg = cph;
                            }
                        }
                        votes[I_max_arg] += 1.0;
                    }
                }
                // check the one with most votes
                int best = -1;
                float best_n = 0;
                for (int v = 0; v < num_cand_phases; v++) {
                    if (votes[v] > best_n) {
                        best = v;
                        best_n = votes[v];
                    }
                }

                nphase = cand_phases[best];
            } else if (u_OptMethod == OM_AVERAGE) {
                vec2 tv = vec2(0.0);

                for (uint k2 = 0; k2 < K * NFLOATS * 9; k2 += NFLOATS) {
                    npos.x = kernels[k2];
                    npos.y = kernels[k2 + 1];
                    nfrequ = gs.x * kernels[k2 + 2];
                    nphase = kernels[k2 + 3];
                    nangle = kernels[k2 + 4];
                    if (npos.x > -10.0) { // border clamping
                        vec2 ph =
                            phasor(kpos - npos, nphase, vec2(cos(nangle), sin(nangle)), nfrequ);
                        if (length(ph) > 1e-6) {
                            float w = max(0.0, dot(vec2(cos(nangle), sin(nangle)),
                                                   vec2(cos(kangle), sin(kangle))));
                            tv += w * normalize(ph);
                        }
                    }
                }

                nphase = atan(tv.y, tv.x);
            }

            imageStore(u_Kernels,
                       int((gl_WorkGroupID.x * K + gl_LocalInvocationID.x) * NFLOATS) + 3,
                       vec4(nphase));
        }
        memoryBarrierImage();
    }
}
