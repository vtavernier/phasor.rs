#version 460 core
#extension GL_ARB_shader_image_load_store : enable

#define K int(u_KernelCount)
#include "shared.h"

// TODO: All local invocations in [u_KernelCount, MAX_K[ are
// not getting any work done, there might be a more efficient way
layout(local_size_x = MAX_K) in;

layout(location = 4) uniform int u_OptMethod;
layout(location = 5) uniform uint u_OptSteps;

#include "gabor.glsl"

shared Kernel[MAX_K * 9] kernels;

float get_average_phase(vec2 gs, Kernel k) {
    vec2 tv = vec2(0.0);

    Kernel n;

    for (uint k2 = 0; k2 < K * 9; ++k2) {
        n = kernels[k2];

        if (n.pos.x > -10.0) { // border clamping
            vec2 ph =
                phasor(k.pos - n.pos, n.phase, vec2(cos(n.angle), sin(n.angle)), n.frequency);
            if (length(ph) > 1e-6) {
                float w = max(
                    0.0, dot(vec2(cos(n.angle), sin(n.angle)), vec2(cos(k.angle), sin(k.angle))));
                tv += w * normalize(ph);
            }
        }
    }

    return atan(tv.y, tv.x);
}

void main() {
    int gi = int(gl_WorkGroupID.x) % u_Grid.x;
    int gj = int(gl_WorkGroupID.x) / u_Grid.x;
    vec2 gs = 32.0 / vec2(u_Grid.xy);
    int kernelId = int(gl_LocalInvocationID.x);

    for (uint opt_steps = 0; opt_steps < max(1u, u_OptSteps); ++opt_steps) {
        // Prefetch kernels into shared memory
        for (int j = -1; j <= 1; j++) {
            for (int i = -1; i <= 1; i++) {
                int ci = cell_idx(i + gi);
                int cj = cell_idy(j + gj);
                uint kid = ((i + 1) + (j + 1) * 3) * K + kernelId;

                if (ci > -1 && cj > -1 && kernelId < K) {
                    int idx = (ci + cj * u_Grid.x) * K + kernelId;

                    kernels[kid] = load_at_idx(idx, vec2(ci, cj));
                    kernels[kid].frequency *= gs.x;
                } else {
                    kernels[kid] = invalid_kernel();
                }
            }
        }
        memoryBarrierShared();

        if (kernelId < K) {
            uint kid = 4 * K + kernelId;
            Kernel k = kernels[kid];
            Kernel n;

            if ((u_OptMethod & OM_OPTIMIZE_BIT) == OM_OPTIMIZE_BIT) {
                float phase_inc = gs.x * k.frequency * 2.0f * M_PI / 64.0;
                // Base number of optimization choices
                const int NUM_CAND_PHASES = 3;
                // Optimization choices
                float cand_phases[NUM_CAND_PHASES + 1] = {k.phase, k.phase - phase_inc,
                    k.phase + phase_inc, 0.};

                const int num_cand_phases = ((u_OptMethod & OM_AVERAGE_BIT) == OM_AVERAGE_BIT ? 1 : 0) + NUM_CAND_PHASES;

                if (num_cand_phases > NUM_CAND_PHASES) {
                    cand_phases[NUM_CAND_PHASES] = get_average_phase(gs, k);
                }

                // Record votes
                float votes[NUM_CAND_PHASES + 1];
                for (int i = 0; i < num_cand_phases; i++) {
                    votes[i] = 0;
                }

                // For each neighbor, include self
                for (uint k2 = 0; k2 < K * 9; ++k2) {
                    n = kernels[k2];
                    if (n.pos.x > -10.0) // border clamping
                    {
                        // evaluate at mid-point
                        vec2 pos = (k.pos + n.pos) / 2.0;
                        // try each phase update, select best
                        float I_max = -1.0;
                        int I_max_arg = -1;
                        vec2 nv = phasor(pos - n.pos, n.phase, vec2(cos(n.angle), sin(n.angle)),
                                         n.frequency);
                        for (int cph = 0; cph < num_cand_phases; cph++) {
                            if ((u_OptMethod & OM_COND_AVERAGE) == OM_COND_AVERAGE && (cph > 0 && cph < NUM_CAND_PHASES))
                                continue;

                            vec2 kv = phasor(pos - k.pos, cand_phases[cph],
                                             vec2(cos(k.angle), sin(k.angle)), k.frequency);
                            float I = length(nv + kv);
                            if (I > I_max) {
                                I_max = I;
                                I_max_arg = cph;
                            }
                        }
                        votes[I_max_arg] += 1.0;
                    }
                }
                // check the one with most votes
                int best = -1;
                float best_n = 0;
                for (int v = 0; v < num_cand_phases; v++) {
                    if (votes[v] > best_n) {
                        best = v;
                        best_n = votes[v];
                    }
                }

                n.phase = cand_phases[best];

                if (best >= NUM_CAND_PHASES) {
                    n.state = 1.0;
                } else {
                    n.state = 0.0;
                }
            } else if (u_OptMethod == OM_AVERAGE) {
                n.phase = get_average_phase(gs, k);
                n.state = 1.0;
            }

            save_phase_at_idx(int(gl_WorkGroupID.x * K + gl_LocalInvocationID.x), n.phase);
            save_state_at_idx(int(gl_WorkGroupID.x * K + gl_LocalInvocationID.x), n.state);
        }
        memoryBarrierImage();
    }
}
